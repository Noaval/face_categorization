---
title: "beysian_analysis"
format: html
editor: visual
---

# Loading data

```{r}

setwd("C:/Users/97252/Documents/GitHub/face_cater/Study 1")
data <- readRDS("C:/Users/97252/Documents/GitHub/face_cater/Study 1/data/preprocessed_data.rds")
```

#### Colors for plots

```{r}
color_vec <- c("#4b3d8f", "#37a987")
```

# Reaction time

## Tidying

```{r}

library(dplyr)
data_clean <- data |>
  mutate(Name = factor(Name),
         Ethnicity = factor(Ethnicity, levels = c("JEWISH", "ARAB")),
         identity = factor(Identity, levels = c("Same", "Diff")),
         target_sex = factor(target_sex, levels = c("male", "female")),
         id = factor(Participant_Private_ID)) |>  # Corrected this line
  # mutate(Ethnicity_e = case_when(Ethnicity == "ARAB" ~ 1,
  #                                Ethnicity == "JEWISH" ~ -1),  ## for factor effect coding
  #        identity_e = case_when(identity == "Diff" ~ 1,
  #                               identity == "Same" ~ -1),
         # target_sex_e = case_when(target_sex == "male" ~ 1,
         #                          target_sex == "female" ~ -1)) |>
  group_by(id) |>
  mutate(trial = row_number(id)) |>
  ungroup() |>
  filter(Correct_Identity == "yes")


contrasts(data_clean$Ethnicity) <- contr.sum(2)
contrasts(data_clean$identity) <- contr.sum(2)


contrasts(data_clean$Ethnicity)
contrasts(data_clean$identity)
```




# Bayesian analysis - Robustness check

Fitting the models again with Posterior sampling.

```{r}
library(Rcpp)

library(brms)
library(tidybayes)
library(posterior)
cmdstanr::check_cmdstan_toolchain()


cmdstanr::check_cmdstan_toolchain()
cmdstanr::check_cmdstan_toolchain(fix = TRUE)
cmdstanr::install_cmdstan()

```

```{r}
#| echo: false
cmdstanr::set_cmdstan_path(path = "C:\\Users\\97252\\Documents\\.cmdstan\\cmdstan-2.34.1")
```

## Reaction time

### Formula

```{r}
#| eval: false
rt_formula <- bf(log(Reaction_time) ~ Ethnicity * identity + (1 + Ethnicity * identity | id),
                 sigma ~ 1 + Ethnicity * identity) # modeling sigma for robustness check)
```

### Prior elicitation

Prior means are equal to the coefficients found by Reggev et al., [-@reggev_human_2020], with medium size variance.

```{r}
#| eval: false
rt_prior <- set_prior("normal(6.03, 1)", class = "Intercept") +
  set_prior("normal(0.01, 1)", coef = "EthnicityARAB") +
  set_prior("normal(0.1, 1)", coef = "identityDiff") +
  set_prior("normal(-0.04, 1)", coef = "identityDiff:EthnicityARAB") +
  set_prior("exponential(1)", class = "sd") # sd of random effects
```

### Model

```{r}
#| eval: false
rt_b_model <- brm(formula = rt_formula,
                  data = data_clean,
                  family = gaussian(),
                  iter = 8000,
                  chains = 4,
                  init = 0,
                  cores = 4,
                  backend = "rstan",
                  seed = 14)
```

```{r}
#| eval: false
#| echo: false

# Define the directory where the file will be saved
dir_path <- "../models"

# Check if the directory exists, and create it if it doesn't
if (!dir.exists(dir_path)) {
  dir.create(dir_path, recursive = TRUE)
}

# Now, try saving the file again
saveRDS(rt_b_model, file = paste0(dir_path, "/reaction_time_bayes_model_maximal.rds"))
```

```{r}
#| echo: false
rt_b_model <- readRDS("../models/reaction_time_bayes_model_maximal.rds")
```

```{r}
library(parameters)
model_parameters(rt_b_model, exponentiate = T, centrality = "all") |> insight::print_html()
```

### Visualization - Posterior Predictive Distributions

```{r}
#| echo: false
#| eval: false

library(tidybayes)
summary(rt_b_model)
chains <- spread_draws(rt_b_model, 
                       b_Intercept, 
                       b_EthnicityARAB, 
                       b_identityDiff, 
                       `b_EthnicityARAB:identityDiff`,
                       b_sigma_Intercept, 
                       b_sigma_EthnicityARAB, 
                       b_sigma_identityDiff, 
                       `b_sigma_EthnicityARAB:identityDiff`)



chains <- spread_draws(rt_b_model, b_Intercept, b_Ethnicity1, b_identity1, !!sym("b_Ethnicity1:identity1"), b_sigma_Intercept, b_sigma_Ethnicity1, b_sigma_identity1, !!sym("b_sigma_Ethnicity1:identity1")) |>
  mutate(across(!c(.chain, .iteration, .draw), exp)) |>
  mutate(mu_JEWISH_same = b_Intercept,
         sd_JEWISH_same = sqrt(b_sigma_Intercept),
         mu_JEWISH_diff = b_Intercept * b_identity1,
         sd_JEWISH_diff = sqrt(b_sigma_Intercept * b_sigma_identity1),
         mu_ARAB_same = b_Intercept * b_Ethnicity1,
         sd_ARAB_same = sqrt(b_sigma_Intercept * b_sigma_Ethnicity1),
         mu_ARAB_diff = b_Intercept * b_identity1 * b_Ethnicity1 * !!sym("b_Ethnicity1:identity1"),
         sd_ARAB_diff = sqrt(b_sigma_Intercept * b_sigma_identity1 * b_sigma_Ethnicity1 * !!sym("b_sigma_Ethnicity1:identity1")))
```


```{r}

model_parameters(rt_b_model)
chains <- spread_draws(rt_b_model, 
                       Intercept, 
                       Ethnicity1, 
                       identity1, 
                       `Ethnicity1:identity1`,
                       sigma_Intercept, 
                       sigma_Ethnicity1, 
                       sigma_identity1, 
                       `sigma_Ethnicity1:identity1`) %>%
  mutate(across(where(is.numeric), exp)) %>%
  mutate(mu_JEWISH_same = Intercept,
         sd_JEWISH_same = sqrt(sigma_Intercept),
         mu_JEWISH_diff = Intercept + identity1,
         sd_JEWISH_diff = sqrt(sigma_Intercept + sigma_identity1),
         mu_ARAB_same = Intercept + Ethnicity1,
         sd_ARAB_same = sqrt(sigma_Intercept + sigma_Ethnicity1),
         mu_ARAB_diff = Intercept + identity1 + Ethnicity1 + `Ethnicity1:identity1`,
         sd_ARAB_diff = sqrt(sigma_Intercept + sigma_identity1 + sigma_Ethnicity1 + `sigma_Ethnicity1:identity1`))
```



```{r}
#| eval: false
#| code-fold: true
#| code-summary: "setting up data for plot"


new_data <- expand_grid(id = unique(data_clean$Participant_Public_ID),
                        identity = unique(data_clean$identity),
                        Ethnicity = unique(data_clean$Ethnicity))

pp <- posterior_predict(rt_b_model, newdata = new_data) |>
  data.frame()

pp_t <- new_data |>
  cbind(data.frame(t(pp))) |>
  mutate(across(!c(id, identity, Ethnicity), exp))

names(pp_t) <- c("id", "identity", "Ethnicity", paste0("draw", c(1:16000), sep = ""))

pp_t <- pp_t |>
  select(-id) |>
  pivot_longer(cols = !c(identity, Ethnicity),
               names_to = ".draw",
               values_to = ".value")
```

```{r}
#| eval: false
#| code-fold: true
#| code-summary: "ggplot code"
rt_b_plot <- pp_t |>
  #group_by(identity, Ethnicity) |>
  #slice_sample(prop = 0.01) |> # used to speed plotting
  ggplot(aes(y = .value, x = identity, color = Ethnicity, fill = Ethnicity)) +
    stat_halfeye(aes(alpha = 1), position = position_dodge(0.2), slab_color = "gray49") +
    scale_fill_manual(values = color_vec, labels = c("JEWISH", "ARAB")) +
    scale_color_manual(values = color_vec) +
    scale_y_continuous(limits = c(200, 1000), breaks = seq(200, 1000, 100), labels = seq(200, 1000, 100)) +
    scale_x_discrete(labels = c("Same", "Different")) +
    theme_classic() +
    guides(alpha = "none", color = "none") +
    labs(x = "Second Face", y = "Reaction Time (ms)", title = "Posterior Predictive Distributions of Reaction Times", subtitle = "Shorter predicted reaction times for 'same' faces, no evidence for an interaction with Social Status", alpha = NULL, fill = "Social Status") +
    theme(plot.title = element_text(size = 20, family = "serif", hjust = 0.5),
          plot.subtitle = element_text(size = 12, family = "serif", hjust = 0.5),
          axis.title = element_text(size = 13, family = "serif"),
          legend.title = element_text(size = 13, family = "serif", hjust = 0.5))

rt_b_plot
```

![](../plots/bayes_dist_plot_rt.png){fig-align="center"}

```{r}
#| eval: false
#| echo: false
ggsave("../plots/bayes_dist_plot_rt.png", plot = rt_b_plot, width = 2450, height = 2100, units = "px")
```

### Visualization - Linear predictor

```{r}
#| echo: false
set.seed(14)
```

```{r}
#| code-fold: true
#| code-summary: "setting up data for plot"
new_data_rt <- expand_grid(id = sample(data_clean$Participant_Public_ID, 10),
                           identity = unique(data_clean$identity),
                           Ethnicity = unique(data_clean$Ethnicity))

rt_pred <- new_data_rt |>
  add_linpred_draws(rt_b_model, ndraws = 100, seed = 14) |>
  mutate(.linpred = exp(.linpred),
         identity = factor(case_when(identity == "Diff" ~ "Different",
                              .default = "Same"), levels = c("Same", "Different")),
         Ethnicity = factor(case_when(Ethnicity == "ARAB" ~ "ARAB",
                                   .default = "JEWISH"), levels = c("JEWISH", "ARAB")))

rt_pred_grand_means <- rt_pred |>
  group_by(identity, Ethnicity) |>
  reframe(grand_mean = mean(.linpred))
```

```{r}
#| code-fold: true
#| code-summary: "ggplot code"
rt_line_plot <- rt_pred |>
  mutate(id = factor(id)) |>
  ggplot(aes(x = identity, y = .linpred, color = id, group = interaction(id, .draw))) +
  geom_line(alpha = 0.8) +
  scale_color_brewer(type = "div", palette = 9) +
  geom_point(data = rt_pred_grand_means, aes(x = identity, y = grand_mean),
             size = 2,
             inherit.aes = F) +
  geom_line(data = rt_pred_grand_means, aes(x = identity, y = grand_mean, group = Ethnicity),
             linewidth = 1,
             inherit.aes = F) +
  scale_y_continuous(limits = c(350, 750), breaks = seq(350, 750, 50), labels = seq(350, 750, 50)) +
  facet_wrap(~Ethnicity) +
  guides(color = "none") +
  labs(x = "Second Face", y = "Reaction Time (ms)", title = "Posterior conditional means of RT for 10 random participants", subtitle = "Participants differ by lines color, great variance in intercepts and slopes for face condition can be seen", color = NULL) +
  theme_classic() +
  theme(plot.title = element_text(size = 19, family = "serif", hjust = 0.5),
        plot.subtitle = element_text(size = 11, family = "serif", hjust = 0.5),
        axis.title = element_text(size = 12, family = "serif"))

rt_line_plot
```

```{r}
#| eval: false
#| echo: false
ggsave("../plots/bayes_spaghetti_plot_rt.png", plot = rt_line_plot, width = 2450, height = 2100, units = "px")
```

## Correct answers

### Formula

```{r}
#| eval: false
ca_formula_0 <- bf(identity_response ~ 1 + (1 | id))

ca_formula_1 <- bf(identity_response ~ identity + Ethnicity + (1 | id))

ca_formula_2 <- bf(identity_response ~ identity * Ethnicity + (1 | id))

ca_formula_maximal <- bf(identity_response ~ identity * Ethnicity + (1 + identity * Ethnicity | id),
                         disc ~ 1 + identity * Ethnicity,
                         nl = TRUE)
```

### Prior elicitation

Based on Reggev et al., 2020 [-@reggev_human_2020]. Normal prior with means equal to the coefficients found previously. Prior will be defined only in the maximal model.

```{r}
#| eval: false
ca_prior <- set_prior("normal(-0.12, 1)", class = "Intercept") +
  set_prior("normal(0.13, 1)", coef = "EthnicityARAB") +
  set_prior("normal(0.02, 1)", coef = "identityDiff") +
  set_prior("normal(0.11, 1)", coef = "identityDiff:EthnicityARAB") +
  set_prior("exponential(1)", class = "sd") # sd of random effects
```

### Model

```{r}
#| eval: false
ca_b_model0 <- brm(formula = ca_formula_0,
                  data = data_clean_ca,
                  family = bernoulli(link = "probit"),
                  iter = 2000,
                  chains = 4,
                  init = 0,
                  cores = 4,
                  backend = "cmdstanr",
                  seed = 14)
```

```{r}
#| echo: false
#| eval: false
write_rds(ca_b_model0, file = "../models/correct_answers_bayes_model0.rds")
```

```{r}
#| echo: false
ca_b_model0 <- read_rds("../models/correct_answers_bayes_model0.rds")
```

```{r}
model_parameters(ca_b_model0, centrality = "all") |> insight::print_html()
```

```{r}
#| eval: false
ca_b_model1 <- update(ca_b_model0,
                      formula = ca_formula_1,
                      newdata = data_clean_ca)
```

```{r}
#| echo: false
#| eval: false
write_rds(ca_b_model1, file = "../models/correct_answers_bayes_model1.rds")
```

```{r}
#| echo: false
ca_b_model1 <- read_rds("../models/correct_answers_bayes_model1.rds")
```

```{r}
model_parameters(ca_b_model1, centrality = "all") |> insight::print_html()
```

```{r}
#| eval: false
ca_b_model2 <- update(ca_b_model1,
                      formula = ca_formula_2)
```

```{r}
#| echo: false
#| eval: false
write_rds(ca_b_model2, file = "../models/correct_answers_bayes_model2.rds")
```

```{r}
#| echo: false
ca_b_model2 <- read_rds("../models/correct_answers_bayes_model2.rds")
```

```{r}
model_parameters(ca_b_model2, centrality = "all") |> insight::print_html()
```

```{r}
#| eval: false
ca_b_model_maximal <- brm(formula = ca_formula_maximal,
                          data = data_clean_ca,
                          family = bernoulli(link = "probit"),
                          prior = ca_prior,
                          iter = 2000,
                          chains = 4,
                          init = 0,
                          cores = 4,
                          backend = "cmdstanr",
                          seed = 14)
```

```{r}
#| echo: false
#| eval: false
write_rds(ca_b_model_maximal, file = "../models/correct_answers_bayes_model_maximal.rds")
```

```{r}
#| echo: false
ca_b_model_maximal <- read_rds("../models/correct_answers_bayes_model_maximal.rds")
```

```{r}
model_parameters(ca_b_model_maximal, centrality = "all") |> insight::print_html()
```

### Visualization

```{r}
#| code-fold: true
#| code-summary: "extracting MCMC draws"
chains <- spread_draws(ca_b_model_maximal, b_Intercept, b_identityDiff, b_EthnicityARAB, !!sym("b_identityDiff:EthnicityARAB"))

chains_for_plot <- chains |>
  mutate(criterion_JEWISH = -b_Intercept,
         criterion_ARAB = -b_Intercept - b_EthnicityARAB,
         d_prime_JEWISH = b_identityDiff,
         d_prime_ARAB = b_identityDiff + !!sym("b_identityDiff:EthnicityARAB")) |>
  select(.draw, criterion_JEWISH, d_prime_JEWISH, criterion_ARAB, d_prime_ARAB)

sdt_params <- chains_for_plot |>
  select(-.draw) |>
  mutate_all(rvar)
sdt_params <- sdt_params[1,]
```

```{r}
#| code-fold: true
#| code-summary: "setting up data for plot"
signal_dist_JEWISH_same <- chains_for_plot |>
  group_by(.draw) |>
  reframe(
    x = seq(-4, 6, length=200),
    d = dnorm(x, mean = 0, sd = 1)
  ) |>
  ungroup() |>
  curve_interval(.along = x, .width = 0.9)

signal_dist_JEWISH_diff <- chains_for_plot |>
  group_by(.draw) |>
  reframe(
    x = seq(-4, 6, length=200),
    d = dnorm(x, mean = d_prime_JEWISH, sd = 1)
  ) |>
  ungroup() |>
  curve_interval(.along = x, .width = 0.9)

signal_dist_ARAB_same <- chains_for_plot |>
  group_by(.draw) |>
  reframe(
    x = seq(-4, 6, length=200),
    d = dnorm(x, mean = 0, sd = 1)
  ) |>
  ungroup() |>
  curve_interval(.along = x, .width = 0.9)

signal_dist_ARAB_diff <- chains_for_plot |>
  group_by(.draw) |>
  reframe(
    x = seq(-4, 6, length=200),
    d = dnorm(x, mean = d_prime_ARAB, sd = 1)
  ) |>
  ungroup() |>
  curve_interval(.along = x, .width = 0.9)
```

```{r}
#| code-fold: true
#| code-summary: "ggplot code"
plot_range <- c(-3, 6)

plot1 <- ggplot() +
    # Noise
    geom_ribbon(aes(x = x, ymin = .lower, ymax = .upper),
                data = signal_dist_JEWISH_same,
                fill = "grey", alpha = 0.4) +
    geom_line(aes(x, d, linetype = "Same"), data = signal_dist_JEWISH_same) +
    # Noise + Signal
    geom_ribbon(aes(x = x, ymin = .lower, ymax = .upper),
                data = signal_dist_JEWISH_diff,
                fill = "grey", alpha = 0.4) +
    geom_line(aes(x, d, linetype = "Different"), data = signal_dist_JEWISH_diff) +
  
    # Threshold
    stat_slab(aes(xdist = criterion_JEWISH), fill = color_vec[1],
              color = "gray", alpha = 0.6, key_glyph = "polygon",
              data = sdt_params) +

    # Theme and scales
    labs(color = NULL, linetype = "Second Face", fill = "Criterion", x = "", y = NULL, title = NULL, subtitle = "JEWISH Status") +
    scale_x_continuous(limits = plot_range, breaks = seq(plot_range[1], plot_range[2]), labels = seq(plot_range[1], plot_range[2])) +
    theme_classic() +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          plot.subtitle = element_text(size = 15, family = "serif"))

plot2 <- ggplot() +
    # Noise
    geom_ribbon(aes(x = x, ymin = .lower, ymax = .upper),
                data = signal_dist_ARAB_same,
                fill = "grey", alpha = 0.4) +
    geom_line(aes(x, d, linetype = "Same"), data = signal_dist_JEWISH_same) +
    # Noise + Signal
    geom_ribbon(aes(x = x, ymin = .lower, ymax = .upper),
                data = signal_dist_ARAB_diff,
                fill = "grey", alpha = 0.4) +
    geom_line(aes(x, d, linetype = "Different"), data = signal_dist_JEWISH_diff) +
  
    # Threshold
    stat_slab(aes(xdist = criterion_ARAB), fill = color_vec[1],
              color = "gray", alpha = 0.6, key_glyph = "polygon",
              data = sdt_params) +

    # Theme and scales
    labs(color = NULL, linetype = "Second Face", fill = "Criterion", x = "", y = NULL, title = NULL, subtitle = "ARAB Status") +
    scale_x_continuous(limits = plot_range, breaks = seq(plot_range[1], plot_range[2]), labels = seq(plot_range[1], plot_range[2])) +
    theme_classic() +
    theme(axis.text.y = element_blank(),
          axis.ticks.y = element_blank(),
          plot.subtitle = element_text(size = 15, family = "serif"))


plot_all <- (plot1 / plot2) +
  plot_layout(guides = "collect") +
  plot_annotation(title = "Signal Detection Perspective",
                  subtitle = str_wrap("Signal and Noise distributions are nicely separated, with the criterion located in the ideal spot (halfway between the distributions)", width = 100),
                  theme = theme(plot.title = element_text(size = 20, family = "serif", hjust = 0.5),
                                plot.subtitle = element_text(size = 12, family = "serif", hjust = 0.5)))

plot_all
```

```{r}
#| eval: false
#| echo: false
ggsave("../plots/bayes_dist_plot_ca.png", plot = plot_all, width = 2450, height = 2100, units = "px")
```

# Environment

```{r}
sessionInfo()
```
